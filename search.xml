<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux tree命令]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4%2FLinux%20tree%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[从需求说起很多时候，比如写博文或者写README.md的时候，我们常常需要以树状图列出目录的内容用作说明。Linux有一个很强大的命令刚好可以实现这个需求。 但是除了简单的显示目录结构外，我们还有一些额外过分的需求，比如只显示某些目录不显示文件、排除某类型的文件、排除深度超过多少的文件等等。 没关系，tree都能实现！！！ 语法 tree [-aACdDfFgilLnNpqstux][-I &lt;范本样式&gt;][-P &lt;范本样式&gt;][目录…] 参数说明(以下为常用的几条，完整版见链接) -C 在文件和目录清单加上色彩，便于区分各种类型。 -d 只显示目录不显示文件。 -I &lt;范本样式&gt; 排除指定内容 -P &lt;范本样式&gt; 只显示符合范本样式的文件或目录名称。 -L 只显示指定层级的内容 示例原样显示： 颜色显示： 排除某个目录： 组合多个参数使用：]]></content>
      <categories>
        <category>每天一个Linux命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alexnet基本思想与Pytorch实现]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0backbone%E7%B3%BB%E5%88%97%2FAlexnet%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E4%B8%8EPytorch%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言说来惭愧，作为一名算法工程师，都没怎么好好读过论文。这几年下来，都是需要什么需求，比如毕设课题是关于目标检测方面的，然后先上github搜代码，再大致看看代码涉及到的论文，再把代码弄下来跑跑自己的数据，稍微修改点参数什么的。 What a shame！！！ 这样下去不行滴。正所谓基础不牢，地动山摇。正好最近鼓捣了一个个人博客，这次就系统性的恶补一下所有的基础知识。并将所有知识整理成个人笔记，也希望遇到志同道合的朋友一起学习学习。 接下来的内容分为两个基础系列，一个是基础骨干网络系列，从Alexnet到resnet，还包括mobilenet以及EfficientNet等；另一个是目标检测系列，包括RCNN全系列、YOLO全系列、SSD等。 所有的博客都将采取论文+代码的形式。 论文内容：解决了现有技术的哪些痛点问题、论文中的一些小技巧和细节。 代码内容：Pytorch、GTX1080Ti、数据集介绍、训练时间、单张图片预测时间、模型大小、参数量多少、浮点运算次数、准确率。 从Alexnet开始Alexnet可谓是深度学习大狂潮的一个起飞点，他成功的踹开了深度学习的大门，具有里程碑式的意义。 2012年，Alex Krizhevsky、Ilya Sutskever在多伦多大学Geoff Hinton的实验室设计出了一个深层的卷积神经网络AlexNet，夺得了2012年ImageNet LSVRC的冠军，且准确率远超第二名（top5错误率为15.3%，第二名为26.2%），引起了很大的轰动。AlexNet可以说是具有历史意义的一个网络结构，在此之前，深度学习已经沉寂了很长时间，自2012年AlexNet诞生之后，后面的ImageNet冠军都是用卷积神经网络（CNN）来做的，并且层次越来越深，使得CNN成为在图像识别分类的核心算法模型，带来了深度学习的大爆发。 注：Alexnet的出现证明的深度学习的巨大潜力，但是并不能算是深度学习的开端。深度学习的开端应该是卷积的应用。1989年，LeCun结合反向传播算法与权值共享的卷积神经层发明了卷积神经网络，并首次将卷积神经网络成功应用到美国邮局的手写字符识别系统中。1998年，LeCun提出了卷积神经网络的经典网络模型LeNet-5，再次提高手写字符识别的正确率。在卷积应用之前，也是有神经网络的，不过那时候的神经网络只能算是一个多层感知机，是神经元全连接的形式。一旦加深网络的层数，参数量会剧增。 论文：imagenet-classification-with-deep-convolutional-neural-networks 现存的问题： 网络的层数比较少，如果增加网络的深度，会导致梯度弥散或者梯度消失，模型参数无法得到有效更新。 模型运算量大，训练时间长。 论文中的创新点： 使用了非线性激活函数：ReLU 防止过拟合的方法：Dropout，数据扩充（Data augmentation） 其他：多GPU实现，LRN归一化层的使用（注：LRN的有效性存在争议，不用的时候反而更好的情况也存在。） 个人感受：可以看到，Alexnet中的几条创新之处都不复杂，看起来都很简单，但是却实实在在的创造了奇迹，打开了一个新时代。 在Alexnet之前也是有卷积这个概念的，也有过成功的应用。但是那时候的卷积神经网络能做到的事情，别的方法也同样能做到，而且还能做的更好。 在这之前，神经网络的发展一度陷入瓶颈期，他存在很多问题，饱受人们质疑。 的确，指出一种理论、一种方法、一种现实中的不足和缺陷是很容易的，我们都能做到。很多人在看出了这么一点点现实的时候就开始有了莫名的优越感，甚至开始指点江山，有那么一种众人皆醉我独醒的感受。 但是啊，指出问题很容易，但是给出解决方案却不容易啊。有的人醉心于前者，有的人却埋头于后者。 好了，废话不多说，回到正题。Alexnet的几点创新之中，个人认为Relu和Dropout是最最关键的两点。 relurelu自然不必说了，没有他，网络根本深不起来。 DropoutDropout常常被人们所忽略，但是他的重要性不容质疑。“神经网络之父”Hinton在后来很长一段时间里的演讲中都拿Dropout说事。 深度学习的网络表达能力实在太强，以至于他甚至能将每一条训练输入的所有特征都记住，从而很容易导致过拟合。也就是他能将训练数据中的每一条都预测准确，这样的模型在测试集中的表现就很糟糕了。 看上面这张图，绿色线就是过拟合。可以说是很直观了。将一些没用的东西也学到了。 Alexnet的Pytorch实现代码环境： pytorch 1.2.0 python 3.7 ubuntu 18.04 GTX1080Ti 单GPU 一个好的项目一定要是逻辑清晰的，结构明晰而简单的。给人一种看上去就很赏心悦目的感觉，一定一定不要混乱不堪。 代码结构： 数据加载 模型构建 训练 验证 应用 github 内容 结果 数据集 Caltech256 训练时间 单张图片预测时间 模型大小 参数量多少 浮点运算次数 * 准确率 67% 未完待续]]></content>
      <categories>
        <category>深度学习backbone系列</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
        <tag>Deep Learning</tag>
        <tag>Alexnet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在git中出现中文乱码的解决方案]]></title>
    <url>%2F2019%2F09%2F10%2F%E5%9C%A8git%E4%B8%AD%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[问题：Mac终端使用git status查看的时候中文不能正常显示。 解决办法：1git config --global core.quotepath false]]></content>
      <categories>
        <category>bugs解决方案</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL安装使用]]></title>
    <url>%2F2019%2F09%2F10%2FMySQL%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MySQL1、安装1、检测是否已安装 $ service mysql status 如果出现下面的结果则表示已安装 2、安装如果上一步没有安装的话直接安装： $ sudo apt-get install mysql-server mysql-client #安装服务端与客户端 $ sudo apt-get install mysql-workbench #安装可视化工具 3、检测启动状态 $ service mysql status 以下两张图分别是启动和停止状态。 启动mysql： 方式一：sudo /etc/init.d/mysql start方式二：sudo service mysql start 停止mysql： 方式一：sudo /etc/init.d/mysql stop方式二：sudo service mysql stop 重启mysql： 方式一：sudo /etc/init.d/mysql restart方式二：sudo service mysql restart 4、登录初始情况下 root 账户没有密码，这时普通用户并不能直接使用 mysql 命令直接控制台登录，更不能使用 mysql-workbench 直接连接登录。主要是由于 mysql.user 这张表中 root 用户的 plugin 字段值为 auth_socket，改为 mysql_native_password 即可。同时为了方便之后使用，我们在接下来的操作中顺带给 root 账户设置密码。 123456789101112#查看所有用户select host,user from user;#删除用户名为yang，host为%的用户drop user yang\@&apos;%&apos;;#删除数据库drop database &lt;数据库名&gt;;#创建用户并赋予权限GRANT ALL ON *.* TO &apos;yang&apos;@&apos;localhost&apos; WITH GRANT OPTION;#创建数据库CREATE DATABASE file_base_info;#查看当前用户select USER(); 5、远程登录第一、允许MySQL数据库被远程连接编辑/etc/mysql/mysql.conf.d/mysqld.cnf 配置文件，注释bind-address = 127.0.0.1这一行，然后重启MySQL服务。 第二、授权允许远程连接的用户 以授权root用户为例 mysql&gt; grant all privileges on . to root@”%” identified by “password” with grant option;]]></content>
      <categories>
        <category>教程</category>
        <category>MySQL使用教程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 下 Hexo的安装]]></title>
    <url>%2F2019%2F09%2F07%2Fhexo%E6%95%99%E7%A8%8B%2FMac%20%E4%B8%8B%20Hexo%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Mac 下 Hexo的安装准备条件硬件环境： Mac 笔记本 软件环境： GitHub 账号 Git Node.js npm hexo 本地站点搭建 安装Git在 Mac OS X 中自带 Git，不需要安装 Git，在 Mac terminal 中输入以下命令可以查看 git 版本号： 1git --version 安装Node.jsNode.js 可以直接从官网下载，然后下一步下一步即可完成安装，如下图所示： 从上图中可以看出，node.js 安装完成以后，npm 也被安装完成，简化了工作。检测安装是否成功，可以在 Mac terminal 中输入以下命令查看 node.js 和 npm 的版本号： 12node -vnpm -v 安装HexoGit、Node.js 和 npm 安装完成以后，接下来就可以安装 Hexo 了。在 Mac terminal 中输入以下命令即可执行安装： 1sudo npm install -g hexo-cli 这里开始就出现各种坑了。一直报错说是没有权限。 Error: EACCES: permission denied, access ‘/usr/local/lib/node_modules’ 我都已经给了sudo权限了依然如此。 接下来又放了两个权限大招： 加权限 root用户执行安装 加权限12sudo chown -R `whoami` /usr/local/lib/node_modulessudo chmod -R 774 /usr/local/lib/node_modules/* root用户执行安装1su #如果出现sorry的话，就用sudo su进去，再给root用户设置密码 passwd root 大招放尽，依然没有鸟用。安装时还是出现err 但是！！！仔细一看，报错的一直是fsevents这么个东西啊！！ hexo-cli@2.0.0 这句话就表明hexo已经安装好了啊！！！！！ 输入以下命令查看 Hexo 的版本号： 1hexo -v 如下图所示： 推荐另一种安装方法 安装nvm curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | sh 安装后检查一下是否安装成功： command -v nvm 如果输出nvm三个字则表示安装成功，在bash shell下使用上述命令。 安装npm，node nvm install stable 检查安装: node -vnpm -v 安装hexo npm install -g hexo-cli 检查安装: hexo -v 搞定！！！！ 初始化 Hexo1234hexo init blogcd blognpm installhexo server 在本地查看效果打开浏览器，输入 http://localhost:4000/ 部署到 GitHub以上操作的结果是可以生成一个在本地浏览的博客站点，若想部署到 GitHub 上，请按照如下方式操作即可。因为本博客是托管在 GitHub 上的，所以一个 GitHub 账号是必不可少的，在 GitHub 注册账号这里就不叙述了。 创建 repository，Repository name 的格式必须是：yourGitHubId.github.io，例如我的是：whuhit.github.io Description 可以为空； 免费服务的话，只能选择 Public (公开的) 安装 Git 部署器 npm install hexo-deployer-git –save 修改配置文件在 hexo 的根目录下会有 _config.yml 文件，打开 _config.yml 文件，在文件最末尾，修改如下配置： 123456#Deployment##Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/whuhit/whuhit.github.io branch: master 部署 在 hexo 目录下执行以下命令， 即可完成对将静态博客部署到 GitHub 上 hexo deploy 部署成功以后，在浏览器中输入 http://whuhit.github.io 即可在线浏览自己的博客啦~ 创建新博客执行以下命令： hexo new “test_blog” 在 /hexo/source/_posts/ 目录下即可看到一个名为 test-blog.md 文件。 发布新博客编辑好博客以后，即可执行以下命令部署到GitHub上： 123hexo cleanhexo generatehexo deploy PS：一些快捷键： 1234hexo g == hexo generatehexo d == hexo deployhexo s == hexo serverhexo n == hexo new]]></content>
      <categories>
        <category>教程</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac开发必备工具]]></title>
    <url>%2F2019%2F09%2F07%2FMac%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1、Homebrew安装与配置Homebrew 的安装非常简单，将下面这条命令粘贴到终端： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 等待命令执行完毕。其他配置见官网中文说明。 常用命令 brew help 查看帮助 brew install 安装软件包 brew uninstall 卸载软件包 brew list [–versions] 列出已安装的软件包(包括版本) brew search 查找软件包 brew info 查看软件包信息 brew update 更新brew brew outdated 列出过时的软件包（已安装但不是最新版本） brew upgrade [] 更新过时的软件包（不指定软件包表示更新全部） brew doctor 检查brew运行状态 2、iTerm 2安装 使用 Homebrew 命令brew install iTerm2安装。 配置关于 iTerm 2 的配置可以参考官网介绍，然后根据自己的喜好配置。这里不多说，参考网上各大佬的配置就好。 3、fishfish 可以根据输入自动匹配历史命令。这一点zsh也可以实现，不过需要自己安装插件。 它的一大特点是开箱即用，没有zsh那些繁琐的配置。官网 安装fish从安装到使用都十分的简单,安装只需要下面一条命令就可以了。 brew install fish 安装完了之后，在/etc/shells文件后面加上一句： /usr/local/bin/fish 配置将用户默认命令由 shell 切换到 fish chsh -s /usr/local/bin/fish 如果 /usr/local/bin/fish 不在 /etc/shells 中 则会遇到 chsh: /usr/local/bin/fish: non-standard shell 的错误 其他配置1、默认使用anaconda环境下Python在~/.config/fish/config.fish文件下（没有的话一个创建）加入以下内容： set PATH /Users/yang/anaconda3/anaconda3/bin $PATH 换成你自己的路径就行。 2、自定义欢迎语在~/.config/fish/config.fish文件下加入以下内容： set fish_greeting ‘Talk is cheap. Show me the code.’ 3、自定义函数fish还可以自定义一些简单的功能。 比如一般我们pip install的时候如果速度比较慢，则可以安装文件的时候加一句 -i https://pypi.tuna.tsinghua.edu.cn/simple 就可以临时换源了。 pip install opencv_python -i https://pypi.tuna.tsinghua.edu.cn/simple 但是每次都要去查这个网址，很麻烦，所以我们直接定义一个fast_pip，内容如下，加入~/.config/fish/config.fish文件中就行了。 123function fast_pip pip --no-cache-dir install $argv[1] -i https://pypi.tuna.tsinghua.edu.cn/simpleend 之后想要临时换源安装的时候用以下命令就可以了： fast_pip opencv_python 4、QuickLook系列之预览图片不知道从哪个版本开始，mac查看图片时，已经没法查看图片分辨率大小了。垃圾苹果。 后来，查了一堆资料，终于找到一个好东西：qlImageSize 安装方法： brew cask install qlimagesize 再次预览图片（空格键）的时候就会显示分辨率了。如果安装完没显示的话重启mac就行了。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之pathlib包的使用]]></title>
    <url>%2F2019%2F09%2F06%2FPython%E5%9F%BA%E7%A1%80%2Fpython%E4%B9%8Bpathlib%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[pathlib简介pathlib库在python 3.4以后已经成为标准库，基本上可以代替os.path来处理路径。它采用完全面对对象的编程方式。 在过去，文件的路径是纯字符串，现在它是一个pathlib.Path对象。 为什么要用pathlib在Mac、Linux和Windows这三种不同的操作系统，其文件连接所用正反斜线是不一样的。 来看下三种不同的文件拼接方式： 1、直接字符串相加 1234567data_folder = "source_data/text_files/"file_to_open = data_folder + "raw_data.txt"f = open(file_to_open)print(f.read()) 点评：Low，非常的Low。而且并不能保证每个操作系统都能顺利执行。 p.s:我就是这么用的。（🥶） 2、使用os模块 123456789import os.pathdata_folder = os.path.join(&quot;source_data&quot;, &quot;text_files&quot;)file_to_open = os.path.join(data_folder, &quot;raw_data.txt&quot;)f = open(file_to_open)print(f.read()) 点评：没毛病。大多数人也是这么用的。但是反复使用os.path.join很啰嗦，是一点都不优雅！ 3、pathlib模块 1234567from pathlib import Pathdata_folder = Path(&quot;source_data/text_files/&quot;)file_to_open = data_folder / &quot;raw_data.txt&quot;print(file_to_open.read_text()) 看到没，是不是超级简单。 上面的data_folder和file_to_open都是一个Path对象，不再是一个字符串。 而这个对象有超多非常好用的方法和属性，也重载了一些操作符。 凡是os.path能做到的事情，pathlib.Path也一样能做到。而且能更优雅的实现os.path的功能。 再看几个更神奇的地方： 1234567891011121314151617from pathlib import Pathdata_folder = Path(&quot;source_data/text_files/&quot;)file_to_open = data_folder / &quot;raw_data.txt&quot;print(filename.name) #全名# &quot;raw_data.txt&quot;print(filename.suffix) #格式# &quot;.txt&quot;print(filename.stem) #去掉格式后的名字# &quot;raw_data&quot;print(filename.parent) #所在文件夹# source_data/text_files 之前一般要么是使用split不断的切分字符串，要么就是os.path一层一层的往上找父目录才能实现这些功能。 而pathlib一个属性全搞定。 和 os 功能对应的方法列表 os and os.path pathlib os.path.abspath Path.resolve os.chmod Path.chmod os.mkdir Path.mkdir os.rename Path.rename os.replace Path.replace os.rmdir Path.rmdir os.remove, os.unlink Path.unlink os.getcwd Path.cwd os.path.exists Path.exists os.path.expanduser Path.expanduser and Path.home os.path.isdir Path.is_dir os.path.isfile Path.is_file os.path.islink Path.is_symlink os.stat Path.stat, Path.owner, Path.group os.path.isabs PurePath.is_absolute os.path.join PurePath.joinpath os.path.basename PurePath.name os.path.dirname PurePath.parent os.path.samefile Path.samefile os.path.splitext PurePath.suffix 其他的一些功能pathlib功能太多了，我这里就不一一列举了。 精力有限，我也不打算探索pathlib的全部功能，下面从我写代码时的一些现实需求出发，简单列一下几个常用的方法： 1、获取当前路径1pwd = Path.cwd() 2、获取当前路径下的所有文件夹12345678910pwd1 = Path.cwd()pwd2 = Path(&quot;.&quot;)x1 = [x for x in pwd1.iterdir() if x.is_dir()]x2 = [x for x in pwd2.iterdir() if x.is_dir()]# 这两者是有区别的，一个是绝对路径，一个是相对路径 print(pwd1 is pwd2)# false 3、获取当前路径下的所有文件12pwd = Path(&quot;.&quot;)x1 = [x for x in pwd.iterdir() if x.is_file() and x.suffix == &quot;.py&quot;] 4、获取当前路径下的所有文件夹（包括子文件夹）12pwd2 = Path(&quot;.&quot;)x2 = [x for x in pwd2.glob(&apos;**/*&apos;) if x.is_dir()] 5、获取当前路径下所有文件（包括子文件夹）123pwd2 = Path(&quot;.&quot;)x2 = [x for x in pwd2.glob(&apos;**/*&apos;) if x.is_file()]x2 = [x for x in pwd2.glob(&apos;**/*.py&apos;) if x.is_file()] 6、拼接路径12345data_folder = Path(&quot;source_data/&quot;)train_img = data_folder / &quot;train&quot; / &quot;image&quot;print(train_img) 7、父路径123456789p = Path(&quot;source_data/train/image/people&quot;)print(p.parent)# source_data/train/imageprint(p.parent.parent)# source_data/trainprint(p.parent.parent.parent)# source_data 更多参考资料你应该使用pathlib替代os.path pathlib路径库使用详解 python中文文档]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下删除安装的pkg]]></title>
    <url>%2F2019%2F09%2F05%2FMac%E4%B8%8B%E5%88%A0%E9%99%A4%E5%AE%89%E8%A3%85%E7%9A%84pkg%2F</url>
    <content type="text"><![CDATA[Mac下删除安装的pkg1、找到安装的pkg包的名称比如我要卸载之前安装的Node.js 1pkgutil --pkgs | grep -i nodejs 如下图所示，找到两个包。之前安装的时候也是两个包，没毛病。 2、找到pkg包所在的文件位置12pkgutil --files org.nodejs.npm.pkgpkgutil --files org.nodejs.node.pkg 3、删除相关文件可以直接进入相关文件夹直接删除，另外也可以使用终端命令删除。 12cd /sudo pkgutil --files org.nodejs.node.pkg | xargs rm -r !!!!千万不要用上面的命令，说多了都是泪，😔哎！ 4、忘记关联12sudo pkgutil --forget org.nodejs.npm.pkgsudo pkgutil --forget org.nodejs.node.pkg]]></content>
      <categories>
        <category>安装卸载那些事</category>
      </categories>
      <tags>
        <tag>pkg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python多日志文件输出]]></title>
    <url>%2F2019%2F09%2F05%2FPython%E5%9F%BA%E7%A1%80%2Fpython%E5%A4%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[需求：在实际写代码的过程中，我发现了这么一个问题： 在Python写文件的时候，如果一个文件需要写入几千行甚至上万行的时候，经常会漏写一些数据。这是不能容忍的。 这个时候我的解决办法一般就是通过Python的logging模块来往文件中写数据，这个时候没出现过漏写的情况。 但是，有的时候，我需要把不同的数据写入不同的文件。这个时候就需要设置一下才能实现了。 废话不多说，show you the code。如下： 代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# 多日志文件的简单实现import pathlibimport loggingimport uuidfrom logging.handlers import TimedRotatingFileHandlerimport timeclass Plog(object): &quot;&quot;&quot;docstring for Plog 级别 何时使用 DEBUG 详细信息，典型地调试问题时会感兴趣。 INFO 证明事情按预期工作。 WARNING 表明发生了一些意外，或者不久的将来会发生问题（如‘磁盘满了’）。软件还是在正常工作。 ERROR 由于更严重的问题，软件已不能执行一些功能了。 CRITICAL 严重错误，表明软件已不能继续运行了。 &quot;&quot;&quot; formatter = logging.Formatter(fmt=&apos;[%(asctime)s.%(msecs)03d] [%(levelname)08s] [%(lineno)03s]: %(message)s&apos;, datefmt=&apos;%Y-%m-%d %H:%M:%S&apos;) formatter2 = logging.Formatter(&apos;%(message)s&apos;) def __init__(self, log_file, level=logging.DEBUG,stream=True,msgOnly=False): pdir = pathlib.Path(log_file).parent if not pdir.exists(): pathlib.Path.mkdir(pdir,parents=True) # 父文件夹不存在则自动创建。 self.log_file = log_file self.level = level self.stream = stream self.log_name = str(uuid.uuid1()) # 区分不同日志。 self.logger = logging.getLogger(self.log_name) self.logger.setLevel(self.level) # 日志文件 # handler = logging.FileHandler(self.log_file, mode=&apos;a&apos;) # handler.setFormatter(Plog.formatter) # self.logger.addHandler(handler) handler = TimedRotatingFileHandler(self.log_file, when=&apos;D&apos;, encoding=&quot;utf-8&quot;) if msgOnly: handler.setFormatter(Plog.formatter2) else: handler.setFormatter(Plog.formatter) self.logger.addHandler(handler) # 终端流 if self.stream: streamHandler = logging.StreamHandler() streamHandler.setFormatter(Plog.formatter2) self.logger.addHandler(streamHandler) self.logger.debug(&quot;==========*****start to log*****==========&quot;) def __getattr__(self,item): return getattr(self.logger,item) # logging.getLogger(self.log_name) ## 本想在程序结束的时候添加一句日志结束标记 ## 但是一直报一个错 ## NameError: name &apos;open&apos; is not defined ## 无法解决。所以只能退而求其次在程序开始的时候加开始标记了。 # def __del__(self): # logging.getLogger(self.log_name).debug(&quot;eixt code 00&quot;) # print(&quot;jisdjia&quot;)if __name__ == &quot;__main__&quot;: a = Plog(&quot;a/a/a/a.log&quot;) # b = Plog(&quot;b.log&quot;)() for i in range(1000): a.debug(&quot;critical&quot;) time.sleep(1) # b.debug(&quot;debug&quot;) 不想这么麻烦建个类的话可以简单点，如下： 12345678910111213141516171819import logging#日志1logger1 = logging.getLogger(&quot;logger1&quot;)handler1 = logging.FileHandler(&quot;logger1.log&quot;, mode=&apos;a&apos;)logger1.addHandler(handler1)logger1.setLevel(logging.DEBUG)#日志2logger2 = logging.getLogger(&quot;logger2&quot;)handler2 = logging.FileHandler(&quot;logger2.log&quot;, mode=&apos;a&apos;)logger2.addHandler(handler2)logger2.setLevel(logging.INFO)print(logging.getLogger(&apos;logger1&apos;) is logger1) #truelogger1.debug(&quot;this is a debug msg&quot;)logger2.error(&quot;this is an error msg&quot;) 下面是关于logging模块的更多详细资料： Python日志库logging总结]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为已绑定的自定义域名启用HTTPS访问]]></title>
    <url>%2F2019%2F09%2F04%2Fhexo%E6%95%99%E7%A8%8B%2Fhttps-setting%2F</url>
    <content type="text"><![CDATA[为已绑定的自定义域名启用HTTPS访问打开 DNS 服务商的 DNS 记录修改页面。(我用的是阿里云的DNS) 原来域名 A 记录指向的IP地址是 192.30.252.153 和 192.30.252.154 ，增加下面几个新地址: 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 保存修改后，等待 DNS 记录生效。 然后，打开 GitHub Pages 设置页面： 1、找到处于不可选状态的Enforce HTTPS选项，如果不添加上面几条新的ip地址，旁边会提示: Unavailable for your site because your domain is not properly configured to support HTTPS。 2、将填在Custom domain里的自定义域名清空，保存，然后重新填上自定义域名，再保存。 3、现在可以勾选Enforce HTTPS选项了，这时会提示正在签发证书: Not yet available for your site because the certificate has not finished being issued。 4、证书签发成功后，可以使用 https 链接访问自定义域名了。 参考链接: Troubleshooting custom domains]]></content>
      <categories>
        <category>教程</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pytorch奇技淫巧]]></title>
    <url>%2F2019%2F09%2F03%2FPytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fpytorch%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[pytorch奇技淫巧1、cudnn加速12torch.backends.cudnn.enabled = Truetorch.backends.cudnn.benchmark = True 设置 torch.backends.cudnn.benchmark=True 将会让程序在开始时花费一点额外时间，为整个网络的每个卷积层搜索最适合它的卷积实现算法，进而实现网络的加速。适用场景是网络结构固定（不是动态变化的），网络的输入形状（包括 batch size，图片大小，输入的通道）是不变的，其实也就是一般情况下都比较适用。反之，如果卷积层的设置一直变化，将会导致程序不停地做优化，反而会耗费更多的时间。 那么问题来了，我们需要记住在什么情况下才将这玩意儿设成true呢？ 我的答案是不需要，记那么多东西干啥？？？那不记住咱办？ 试！！！自己训练模型的时候将这个参数设为false和true，分别体验一下，体验几次后自然就知道了。 2、pytorch如何能够保证模型的可重复性问题背景是这样的： 同样的模型，同样的参数，在GPU上运行的结果和CPU运行的结果有些不一致。 解决办法：在主函数中加上一句 1torch.backends.cudnn.deterministic = True 用以保证实验的可重复性。]]></content>
      <categories>
        <category>Pytorch学习笔记</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 个性化配置]]></title>
    <url>%2F2019%2F09%2F03%2Fhexo%E6%95%99%E7%A8%8B%2Fhexo%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1、主题选择之前看到别人的网站，非常惊艳，想照个做一个。看博主的自我介绍，他用的是基于next自己修改过的主题。 真的很不错，直接拿过来用就行。但是配置的时候自己功力不够，出了很多问题，比如设置搜索框的时候就一直没成功过。由于是别人自己修改过的主题，用的人不多，资料比较少，所以无奈只能放弃。 于是，只能找那种开源的很多人用过的主题，这样资料多一点，有问题比较好求助。网上用的比较多的是这一款。直接clone到themes文件夹下就行了。 最终看到了这一款，十分惊艳，直接入坑。这里是文档，这里是最终效果。 文档非常全，我这里就直接引用了，非常感谢原作者。 在站点_config.yml（hexo里面的那个）文件下修改theme就行了。 1theme: Butterfly 之后的站点配置教程可能不适合Butterfly主题。因为next系列主题用的是swig，而Butterfly主题用的是pug。如果你不了解swig和pug也完全没关系，通过一些教程修改过一些配置文件后，差不多就能了解个大致意思了。二者都只是生成最终html文件的一种辅助罢了。 如果想看next主题的一些教程，可以看这位大神的博客。 Hexo 搭建个人博客系列：基础建站篇 Hexo 搭建个人博客系列：写作技巧篇 Hexo 搭建个人博客系列：主题美化篇 Hexo 搭建个人博客系列：进阶设置篇 Hexo 搭建个人博客系列：部署上线篇 实战纪录：将 Hexo 站点备份到 Github 上 2、主页设置修改主题配置文件_config.yml (下载主题里面的配置文件) 1234567menu: 主页: /||fa fa-home 归档: /archives/||fa fa-archive 标签: /tags/||fa fa-tags 目录: /categories/||fa fa-folder-open #链接: /link/||fa fa-link 关于: /about/||fa fa-heart 另外还需要执行以下操作，不然网页上访问会出问题 123hexo new page &quot;about&quot;hexo new page &quot;categories&quot;hexo new page &quot;tags&quot; 3、添加搜索功能安装插件 npm install hexo-generator-searchdb –save 接着，我们进入站点配置文件_config.yml,在最后新增以下内容： 12345search: path: search.xml field: post format: html limit: 10000 最后，打开主题配置文件_config.yml,搜索local_search,其值改为true： 12345678# Local search# Please see doc for more details: https://jerryc.me/posts/21cfbf15/#本地搜索# ---------------local_search: enable: true labels: input_placeholder: Search for Posts hits_empty: &quot;We didn&apos;t find any results for the search: $&#123;query&#125;&quot; # if there are no result 4、添加评论功能 注册Leancloud我们的评论系统其实是放在Leancloud上的，因此首先需要去注册一个账号 Leancloud官网，点我注册 注册完以后需要创建一个应用，名字可以随便起，然后 进入应用-&gt;设置-&gt;应用key 获取你的appid 和 appkey 如图所示： 修改主题配置文件_config.yml。123456789101112# valine comment system. https://valine.js.orgvaline: enable: true # if you want use valine,please set this value is true appId: # leancloud application app id appKey: # leancloud application app key notify: false # valine mail notify (true/false) https://github.com/xCss/Valine/wiki verify: false # valine verify code (true/false) pageSize: 10 # comment list page size avatar: monsterid # gravatar style https://valine.js.org/#/avatar lang: zh-cn # i18n: zh-cn/en placeholder: 留下你的脚印吧... # valine comment input placeholder(like: Please leave your footprints ) guest_info: nick,mail #valine comment header inf 5、网站图标以及个人图像设置这里图像路径如果是本地路径的话，则是相对于主题文件夹下的source而言的。 网站图标：123# Favicon# ---------------favicon: /img/Luffy.ico 个人头像：1234# Post info settings# ---------------# avatar: /img/avatar.pngavatar: /img/10763769_110002102000_2_1550882510273.jpg 6、社交链接修改主题配置文件： 12345# ---------------social: fa fa-github: https://github.com/whuhit fa fa-envelope: mailto:whuhit09@gmail.com #fa fa-rss: /atom.xml 注意邮箱前面加上mailto:，这样点击邮箱那个图标就会自动调用邮箱。]]></content>
      <categories>
        <category>教程</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Pytorch]]></title>
    <url>%2F2019%2F09%2F02%2FPytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E5%88%9D%E8%AF%86pytorch%2F</url>
    <content type="text"><![CDATA[1、tensor属性每一个torch.Tensor都有以下三种属性： torch.dtype torch.device torch.layout torch.dtypePyTorch上的常用数据类型如下，共9种。 Data type dtype CPU tensor GPU tensor Size/bytes 32-bit floating torch.float32 or torch.float torch.FloatTensor torch.cuda.FloatTensor 4 64-bit floating torch.float64 or torch.double torch.DoubleTensor torch.cuda.DoubleTensor 8 16-bit floating torch.float16or torch.half torch.HalfTensor torch.cuda.HalfTensor - 8-bit integer (unsigned) torch.uint8 torch.ByteTensor torch.cuda.ByteTensor 1 8-bit integer (signed) torch.int8 torch.CharTensor torch.cuda.CharTensor - 16-bit integer (signed) torch.int16or torch.short torch.ShortTensor torch.cuda.ShortTensor 2 32-bit integer (signed) torch.int32 or torch.int torch.IntTensor torch.cuda.IntTensor 4 64-bit integer (signed) torch.int64 or torch.long torch.LongTensor torch.cuda.LongTensor 8 Boolean torch.bool torch.BoolTensor torch.cuda.BoolTensor - 以上PyTorch中的数据类型和numpy中的相对应，占用字节大小也是一样的 ———————————————— torch.device Torch.device 是表现 torch.Tensor被分配的设备类型的类，其中分为’cpu’ 和 ‘cuda’两种，如果设备序号没有显示则表示此 tensor 被分配到当前设备, 比如: ‘cuda’ 等同于 ‘cuda’: X , X 为torch.cuda.current _device() 返回值 我们可以通过 tensor.device 来获取其属性，同时可以利用字符或字符+序号的方式来分配设备 12345678910111213通过字符串：&gt;&gt;&gt; torch.device(&apos;cuda:0&apos;)device(type=&apos;cuda&apos;, index=0)&gt;&gt;&gt; torch.device(&apos;cpu&apos;)device(type=&apos;cpu&apos;)&gt;&gt;&gt; torch.device(&apos;cuda&apos;) # 当前设备device(type=&apos;cuda&apos;)通过字符串和设备序号：&gt;&gt;&gt; torch.device(&apos;cuda&apos;, 0)device(type=&apos;cuda&apos;, index=0)&gt;&gt;&gt; torch.device(&apos;cpu&apos;, 0)device(type=&apos;cpu&apos;, index=0) 此外，cpu 和 cuda 设备的转换使用 ‘to’ 来实现： 12345&gt;&gt;&gt; device_cpu = torch.device(&quot;cpu&quot;) #声明cpu设备&gt;&gt;&gt; device_cuda = torch.device(&apos;cuda&apos;) #设备cuda设备&gt;&gt;&gt; data = torch.Tensor([1])&gt;&gt;&gt; data.to(device_cpu) #将数据转为cpu格式&gt;&gt;&gt; data.to(device_cuda) #将数据转为cuda格式 torch.layouttorch.layout 是表现 torch.Tensor 内存分布的类，目前只支持 torch.strided.另外一种方式torch.sparse_coo正在实验阶段。暂时不用管这个。]]></content>
      <categories>
        <category>Pytorch学习笔记</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
</search>
