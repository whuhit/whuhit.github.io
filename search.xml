<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python多日志文件输出]]></title>
    <url>%2F2019%2F09%2F05%2Fpython%E5%A4%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940class Plog(object): &quot;&quot;&quot;docstring for Plog 级别 何时使用 DEBUG 详细信息，典型地调试问题时会感兴趣。 INFO 证明事情按预期工作。 WARNING 表明发生了一些意外，或者不久的将来会发生问题（如‘磁盘满了’）。软件还是在正常工作。 ERROR 由于更严重的问题，软件已不能执行一些功能了。 CRITICAL 严重错误，表明软件已不能继续运行了。 &quot;&quot;&quot; formatter = logging.Formatter(fmt=&apos;[%(asctime)s.%(msecs)03d] [%(levelname)08s] [%(lineno)03s]: %(message)s&apos;, datefmt=&apos;%Y-%m-%d %H:%M:%S&apos;) def __init__(self, log_file, level=logging.DEBUG): pdir = pathlib.Path(log_file).parent if not pdir.exists(): os.makedirs(pdir) self.log_file = log_file self.level = level self.log_name = str(uuid.uuid1()) # 区分不同日志。 log_setup = logging.getLogger(self.log_name) # 日志文件 handler = logging.FileHandler(self.log_file, mode=&apos;a&apos;) handler.setFormatter(Plog.formatter) # 终端流 streamHandler = logging.StreamHandler() streamHandler.setFormatter(Plog.formatter) log_setup.setLevel(self.level) log_setup.addHandler(handler) log_setup.addHandler(streamHandler)if __name__ == &quot;__main__&quot;: a = Plog(&quot;a/a.log&quot;, level=logging.DEBUG) b = Plog(&quot;b.log&quot;, level=logging.INFO) logging.getLogger(a.log_name).critical(&quot;critical&quot;) logging.getLogger(b.log_name).debug(&quot;debug&quot;)]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为已绑定的自定义域名启用HTTPS访问]]></title>
    <url>%2F2019%2F09%2F04%2Fhttps-setting%2F</url>
    <content type="text"><![CDATA[为已绑定的自定义域名启用HTTPS访问打开 DNS 服务商的 DNS 记录修改页面。(我用的是阿里云的DNS) 原来域名 A 记录指向的IP地址是 192.30.252.153 和 192.30.252.154 ，增加下面几个新地址: 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 保存修改后，等待 DNS 记录生效。 然后，打开 GitHub Pages 设置页面： 1、找到处于不可选状态的Enforce HTTPS选项，如果不添加上面几条新的ip地址，旁边会提示: Unavailable for your site because your domain is not properly configured to support HTTPS。 2、将填在Custom domain里的自定义域名清空，保存，然后重新填上自定义域名，再保存。 3、现在可以勾选Enforce HTTPS选项了，这时会提示正在签发证书: Not yet available for your site because the certificate has not finished being issued。 4、证书签发成功后，可以使用 https 链接访问自定义域名了。 参考链接: Troubleshooting custom domains]]></content>
      <categories>
        <category>教程</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch奇技淫巧]]></title>
    <url>%2F2019%2F09%2F03%2Fpytorch%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[pytorch奇技淫巧1、cudnn加速12torch.backends.cudnn.enabled = Truetorch.backends.cudnn.benchmark = True 设置 torch.backends.cudnn.benchmark=True 将会让程序在开始时花费一点额外时间，为整个网络的每个卷积层搜索最适合它的卷积实现算法，进而实现网络的加速。适用场景是网络结构固定（不是动态变化的），网络的输入形状（包括 batch size，图片大小，输入的通道）是不变的，其实也就是一般情况下都比较适用。反之，如果卷积层的设置一直变化，将会导致程序不停地做优化，反而会耗费更多的时间。 那么问题来了，我们需要记住在什么情况下才将这玩意儿设成true呢？ 我的答案是不需要，记那么多东西干啥？？？那不记住咱办？ 试！！！！自己训练模型的时候将这个参数设为false和true，分别体验一下，体验几次后自然就知道了。 2、pytorch如何能够保证模型的可重复性问题背景是这样的： 同样的模型，同样的参数，在GPU上运行的结果和CPU运行的结果有些不一致。 解决办法：在主函数中加上一句 1torch.backends.cudnn.deterministic = True 用以保证实验的可重复性。]]></content>
      <categories>
        <category>pytorch学习笔记</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 下 Hexo的安装]]></title>
    <url>%2F2019%2F09%2F03%2FMac%20%E4%B8%8B%20Hexo%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Mac 下 Hexo的安装准备条件硬件环境： Mac 笔记本 软件环境： GitHub 账号 Git Node.js npm hexo 本地站点搭建 安装Git在 Mac OS X 中自带 Git，不需要安装 Git，在 Mac terminal 中输入以下命令可以查看 git 版本号： 1git --version 安装Node.jsNode.js 可以直接从官网下载，然后下一步下一步即可完成安装，如下图所示： 从上图中可以看出，node.js 安装完成以后，npm 也被安装完成，简化了工作。检测安装是否成功，可以在 Mac terminal 中输入以下命令查看 node.js 和 npm 的版本号： 12node -vnpm -v 安装HexoGit、Node.js 和 npm 安装完成以后，接下来就可以安装 Hexo 了。在 Mac terminal 中输入以下命令即可执行安装： 1sudo npm install -g hexo-cli 这里开始就出现各种坑了。一直报错说是没有权限。 Error: EACCES: permission denied, access ‘/usr/local/lib/node_modules’ 我都已经给了sudo权限了依然如此。 接下来又放了两个权限大招： 加权限 root用户执行安装 加权限12sudo chown -R `whoami` /usr/local/lib/node_modulessudo chmod -R 774 /usr/local/lib/node_modules/* root用户执行安装1su #如果出现sorry的话，就用sudo su进去，再给root用户设置密码 passwd root 大招放尽，依然没有鸟用。安装时还是出现err 但是！！！仔细一看，报错的一直是fsevents这么个东西啊！！ hexo-cli@2.0.0 这句话就表明hexo已经安装好了啊！！！！！ 输入以下命令查看 Hexo 的版本号： 1hexo -v 如下图所示： 初始化 Hexo1234hexo init blogcd blognpm installhexo server 在本地查看效果打开浏览器，输入 http://localhost:4000/ 部署到 GitHub以上操作的结果是可以生成一个在本地浏览的博客站点，若想部署到 GitHub 上，请按照如下方式操作即可。因为本博客是托管在 GitHub 上的，所以一个 GitHub 账号是必不可少的，在 GitHub 注册账号这里就不叙述了。 创建 repository，Repository name 的格式必须是：yourGitHubId.github.io，例如我的是：whuhit.github.io Description 可以为空； 免费服务的话，只能选择 Public (公开的) 安装 Git 部署器 npm install hexo-deployer-git –save 修改配置文件在 hexo 的根目录下会有 _config.yml 文件，打开 _config.yml 文件，在文件最末尾，修改如下配置： 123456#Deployment##Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/whuhit/whuhit.github.io branch: master 部署 在 hexo 目录下执行以下命令， 即可完成对将静态博客部署到 GitHub 上 hexo deploy 部署成功以后，在浏览器中输入 http://whuhit.github.io 即可在线浏览自己的博客啦~ 创建新博客执行以下命令： hexo new “test_blog” 在 /hexo/source/_posts/ 目录下即可看到一个名为 test-blog.md 文件。 发布新博客编辑好博客以后，即可执行以下命令部署到GitHub上： 123hexo cleanhexo generatehexo deploy PS：一些快捷键： 1234hexo g == hexo generatehexo d == hexo deployhexo s == hexo serverhexo n == hexo new]]></content>
      <categories>
        <category>教程</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 个性化配置]]></title>
    <url>%2F2019%2F09%2F03%2Fhexo%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1、主题选择之前看到别人的网站，非常惊艳，想照个做一个。看博主的自我介绍，他用的是基于next自己修改过的主题。 真的很不错，直接拿过来用就行。但是配置的时候自己功力不够，出了很多问题，比如设置搜索框的时候就一直没成功过。由于是别人自己修改过的主题，用的人不多，资料比较少，所以无奈只能放弃。 于是，只能找那种开源的很多人用过的主题，这样资料多一点，有问题比较好求助。网上用的比较多的是这一款。直接clone到themes文件夹下就行了。 最终看到了这一款，十分惊艳，直接入坑。这里是文档，这里是最终效果。 文档非常全，我这里就直接引用了，非常感谢原作者。 在站点_config.yml（hexo里面的那个）文件下修改theme就行了。 1theme: Butterfly 之后的站点配置教程可能不适合Butterfly主题。因为next系列主题用的是swig，而Butterfly主题用的是pug。如果你不了解swig和pug也完全没关系，通过一些教程修改过一些配置文件后，差不多就能了解个大致意思了。二者都只是生成最终html文件的一种辅助罢了。 如果想看next主题的一些教程，可以看这位大神的博客。 Hexo 搭建个人博客系列：基础建站篇 Hexo 搭建个人博客系列：写作技巧篇 Hexo 搭建个人博客系列：主题美化篇 Hexo 搭建个人博客系列：进阶设置篇 Hexo 搭建个人博客系列：部署上线篇 实战纪录：将 Hexo 站点备份到 Github 上 2、主页设置修改主题配置文件_config.yml (下载主题里面的配置文件) 1234567menu: 主页: /||fa fa-home 归档: /archives/||fa fa-archive 标签: /tags/||fa fa-tags 目录: /categories/||fa fa-folder-open #链接: /link/||fa fa-link 关于: /about/||fa fa-heart 另外还需要执行以下操作，不然网页上访问会出问题 123hexo new page &quot;about&quot;hexo new page &quot;categories&quot;hexo new page &quot;tags&quot; 3、添加搜索功能安装插件 npm install hexo-generator-searchdb –save 接着，我们进入站点配置文件_config.yml,在最后新增以下内容： 12345search: path: search.xml field: post format: html limit: 10000 最后，打开主题配置文件_config.yml,搜索local_search,其值改为true： 12345678# Local search# Please see doc for more details: https://jerryc.me/posts/21cfbf15/#本地搜索# ---------------local_search: enable: true labels: input_placeholder: Search for Posts hits_empty: &quot;We didn&apos;t find any results for the search: $&#123;query&#125;&quot; # if there are no result 4、添加评论功能 注册Leancloud我们的评论系统其实是放在Leancloud上的，因此首先需要去注册一个账号 Leancloud官网，点我注册 注册完以后需要创建一个应用，名字可以随便起，然后 进入应用-&gt;设置-&gt;应用key 获取你的appid 和 appkey 如图所示： 修改主题配置文件_config.yml。123456789101112# valine comment system. https://valine.js.orgvaline: enable: true # if you want use valine,please set this value is true appId: # leancloud application app id appKey: # leancloud application app key notify: false # valine mail notify (true/false) https://github.com/xCss/Valine/wiki verify: false # valine verify code (true/false) pageSize: 10 # comment list page size avatar: monsterid # gravatar style https://valine.js.org/#/avatar lang: zh-cn # i18n: zh-cn/en placeholder: 留下你的脚印吧... # valine comment input placeholder(like: Please leave your footprints ) guest_info: nick,mail #valine comment header inf 5、网站图标以及个人图像设置这里图像路径如果是本地路径的话，则是相对于主题文件夹下的source而言的。 网站图标：123# Favicon# ---------------favicon: /img/Luffy.ico 个人头像：1234# Post info settings# ---------------# avatar: /img/avatar.pngavatar: /img/10763769_110002102000_2_1550882510273.jpg 6、社交链接修改主题配置文件： 12345# ---------------social: fa fa-github: https://github.com/whuhit fa fa-envelope: mailto:whuhit09@gmail.com #fa fa-rss: /atom.xml 注意邮箱前面加上mailto:，这样点击邮箱那个图标就会自动调用邮箱。]]></content>
      <categories>
        <category>教程</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识pytorch]]></title>
    <url>%2F2019%2F09%2F02%2F%E5%88%9D%E8%AF%86pytorch%2F</url>
    <content type="text"><![CDATA[1、tensor属性每一个torch.Tensor都有以下三种属性： torch.dtype torch.device torch.layout torch.dtypePyTorch上的常用数据类型如下，共9种。 Data type dtype CPU tensor GPU tensor Size/bytes 32-bit floating torch.float32 or torch.float torch.FloatTensor torch.cuda.FloatTensor 4 64-bit floating torch.float64 or torch.double torch.DoubleTensor torch.cuda.DoubleTensor 8 16-bit floating torch.float16or torch.half torch.HalfTensor torch.cuda.HalfTensor - 8-bit integer (unsigned) torch.uint8 torch.ByteTensor torch.cuda.ByteTensor 1 8-bit integer (signed) torch.int8 torch.CharTensor torch.cuda.CharTensor - 16-bit integer (signed) torch.int16or torch.short torch.ShortTensor torch.cuda.ShortTensor 2 32-bit integer (signed) torch.int32 or torch.int torch.IntTensor torch.cuda.IntTensor 4 64-bit integer (signed) torch.int64 or torch.long torch.LongTensor torch.cuda.LongTensor 8 Boolean torch.bool torch.BoolTensor torch.cuda.BoolTensor - 以上PyTorch中的数据类型和numpy中的相对应，占用字节大小也是一样的 ———————————————— torch.device Torch.device 是表现 torch.Tensor被分配的设备类型的类，其中分为’cpu’ 和 ‘cuda’两种，如果设备序号没有显示则表示此 tensor 被分配到当前设备, 比如: ‘cuda’ 等同于 ‘cuda’: X , X 为torch.cuda.current _device() 返回值 我们可以通过 tensor.device 来获取其属性，同时可以利用字符或字符+序号的方式来分配设备 12345678910111213通过字符串：&gt;&gt;&gt; torch.device(&apos;cuda:0&apos;)device(type=&apos;cuda&apos;, index=0)&gt;&gt;&gt; torch.device(&apos;cpu&apos;)device(type=&apos;cpu&apos;)&gt;&gt;&gt; torch.device(&apos;cuda&apos;) # 当前设备device(type=&apos;cuda&apos;)通过字符串和设备序号：&gt;&gt;&gt; torch.device(&apos;cuda&apos;, 0)device(type=&apos;cuda&apos;, index=0)&gt;&gt;&gt; torch.device(&apos;cpu&apos;, 0)device(type=&apos;cpu&apos;, index=0) 此外，cpu 和 cuda 设备的转换使用 ‘to’ 来实现： 12345&gt;&gt;&gt; device_cpu = torch.device(&quot;cpu&quot;) #声明cpu设备&gt;&gt;&gt; device_cuda = torch.device(&apos;cuda&apos;) #设备cuda设备&gt;&gt;&gt; data = torch.Tensor([1])&gt;&gt;&gt; data.to(device_cpu) #将数据转为cpu格式&gt;&gt;&gt; data.to(device_cuda) #将数据转为cuda格式 torch.layouttorch.layout 是表现 torch.Tensor 内存分布的类，目前只支持 torch.strided.另外一种方式torch.sparse_coo正在实验阶段。暂时不用管这个。]]></content>
      <categories>
        <category>pytorch学习笔记</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
</search>
